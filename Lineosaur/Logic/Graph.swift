//
//  Graph.swift
//  Adjacency Table
//
//  Created by Dylan Conklin on 7/21/23.
//

import Foundation
import SwiftData

typealias Vertex = String

enum GraphType {
    case given
    case mst
}

@Model
class Graph: Equatable {
    private var graphEdges: Set<Edge>
    private var graphVertices: Set<Vertex>
    var name: String?
    var lastAccessed: Date
    var edgeStyles: [UUID: EdgeStyle]
    var id: UUID

    /// Returns the vertices of the graph
    var vertices: [Vertex] {
        get {
            graphVertices.sorted()
        }
        set {
            let newVertices: Set<Vertex> = .init(newValue)
            let difference: Set<Vertex> = .init(vertices).symmetricDifference(newVertices)

            if vertices.count < newVertices.count {
                graphVertices.formUnion(difference)
            } else {
                difference.forEach(remove)
            }
        }
    }

    /// Calculates the total cost of the graph
    /// The cost is the sum of the weight (length) of all the edges in the graph
    var cost: Double {
        edges.reduce(0.0) { $0 + $1.weight }
    }

    /// Generate the Minimum Spanning Tree (MST)
    /// - Returns: The MST Graph generated by the edges in the graph
    var mst: Graph {
        guard isTree else {
            return Graph()
        }

        let graph: Graph = copy
        var verticesLeft: Set<Vertex> = .init(graph.vertices) // vertices that don't have an edge
        let MST: Graph = .init()

        while let edge = graph.edges.sorted(by: { $0.weight < $1.weight }).first(where: { edge in
            let groupA: Set<Vertex> = .init(edge.vertices).intersection(verticesLeft)
            let groupB: Set<Vertex> = .init(edge.vertices).intersection(MST.vertices)
            return !groupA.isEmpty && !groupB.isEmpty
        }) ?? (MST.isEmpty ? graph.edges.min(by: { $0.weight < $1.weight }) : nil) {
            MST.insert(edge)
            graph.remove(edge)
            verticesLeft.subtract(edge.vertices)
        }

        return MST
    }

    /// Returns edges of the graph, in the form of Edge objects in an array
    var edges: [Edge] {
        get {
            graphEdges.sorted { lhs, rhs in
                var result: Bool = lhs.weight < rhs.weight
                if lhs.from != rhs.from {
                    result = lhs.from < rhs.from
                } else if lhs.toward != rhs.toward {
                    result = lhs.toward < rhs.toward
                }
                return result
            }
        }
        set {
            let difference: Set<Edge> = .init(newValue).symmetricDifference(Set(edges))
            let addOrRemove: (Edge) -> Void = edges.count < newValue.count ? { (edge: Edge) in
                self.insert(edge)
            } : { (edge: Edge) in
                self.remove(edge)
            }
            difference.forEach(addOrRemove)
        }
    }

    var copy: Graph {
        Graph(graphEdges: graphEdges, graphVertices: graphVertices)
    }

    var leaves: Set<Vertex> {
        Set<Vertex>(vertices.filter { vertex in
            !edges(connectedTo: vertex).contains { $0.from == vertex }
        })
    }

    var loops: Set<Edge> {
        Set(edges.filter { $0.from == $0.toward })
    }

    init(
        graphEdges: Set<Edge> = Set<Edge>(),
        graphVertices: Set<Vertex> = Set<Vertex>(),
        name: String? = nil,
        edgeStyles: [UUID: EdgeStyle] = [UUID: EdgeStyle]()
    ) {
        self.graphEdges = graphEdges
        self.graphVertices = graphVertices
        self.name = name
        lastAccessed = Date.now
        self.edgeStyles = edgeStyles
        id = UUID()
    }

    static func == (lhs: Graph, rhs: Graph) -> Bool {
        lhs.edges == rhs.edges && lhs.vertices == rhs.vertices
    }

    func deleteEdges() {
        graphEdges = Set<Edge>()
    }

    func deleteEdgesAndVertices() {
        deleteEdges()
        graphVertices = Set<Vertex>()
    }

    func deleteLeaves() {
        remove(leaves)
    }

    func deleteDetachedVertices() {
        vertices.filter { edges(connectedTo: $0).isEmpty }.forEach(remove)
    }

    func edges(from: Vertex, toward: Vertex, directional: Bool = true) -> Set<Edge> {
        Set<Edge>(edges.filter { edge in
            directional ? (edge.toward == toward && edge.from == from) :
                (Set<Vertex>(edge.vertices) == Set<Vertex>([from, toward]))
        })
    }

    func edges(connectedTo vertex: Vertex) -> Set<Edge> {
        Set(edges.filter { $0.vertices.contains(vertex) })
    }

    func edges(connectedTo vertices: any Collection<Vertex>) -> Set<Edge> {
        vertices.reduce(into: Set<Edge>()) { result, vertex in
            result.formUnion(self.edges(connectedTo: vertex))
        }
    }

    func insert(_ vertex: Vertex) {
        graphVertices.insert(vertex)
    }

    func insert(_ edge: Edge, withStyle style: EdgeStyle? = nil) {
        graphEdges.insert(edge)
        insert(edge.from)
        insert(edge.toward)
        edgeStyles[edge.id] = style
    }

    func remove(_ vertex: Vertex) {
        graphEdges.filter { $0.vertices.contains(vertex) }.forEach(remove)
        graphVertices.remove(vertex)
    }

    func remove(_ vertices: any Collection<Vertex>) {
        vertices.forEach(remove)
    }

    func remove(_ edge: Edge) {
        graphEdges.remove(edge)
    }

    func remove(_ edges: any Collection<Edge>) {
        edges.forEach(remove)
    }
}
